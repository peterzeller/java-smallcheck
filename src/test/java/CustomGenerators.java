/*
 * This Java source file was generated by the Gradle 'init' task.
 */

import org.junit.runner.RunWith;
import smallcheck.SmallCheckRunner;
import smallcheck.annotations.RegisterGenerator;
import smallcheck.annotations.StaticFactory;
import smallcheck.annotations.From;
import smallcheck.annotations.Property;
import smallcheck.generators.LongGen;
import smallcheck.generators.SeriesGen;

import java.math.BigInteger;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static org.junit.Assert.assertTrue;


@RunWith(SmallCheckRunner.class)
public class CustomGenerators {


    public static class BigIntegerGen extends SeriesGen<BigInteger> {
        @Override
        public Stream<BigInteger> generate(int depth) {
            return new LongGen().generate(depth).map(BigInteger::valueOf);
        }
    }

    @Property(maxDepth = 20)
    public void test(@From(BigIntegerGen.class) BigInteger i) {
        assertTrue(i.intValue() < 10);
    }


    @Property(maxInvocations = 5000000)
    @StaticFactory(ExprFactory.class)
    public void testExpr(Expr e) {
        assertTrue(e.evaluate() < 8);
    }


    public static class ExprFactory {
        public static Number number(int i) {
            return new Number(i);
        }

        public static Plus plus(Expr a, Expr b) {
            return new Plus(a, b);
        }

        public static Mult mult(Expr a, Expr b) {
            return new Mult(a, b);
        }
    }


    public static abstract class Expr {
        abstract int evaluate();
    }

    public static class Number extends Expr {
        int number;

        public Number(int number) {
            this.number = number;
        }

        @Override
        int evaluate() {
            return number;
        }

        @Override
        public String toString() {
            return "" + number;
        }
    }

    public static class Plus extends Expr {
        Expr left;
        Expr right;

        public Plus(Expr left, Expr right) {
            this.left = left;
            this.right = right;
        }

        @Override
        int evaluate() {
            return left.evaluate() + right.evaluate();
        }

        @Override
        public String toString() {
            return "(" + left + " + " + right + ")";
        }
    }

    public static class Mult extends Expr {
        Expr left;
        Expr right;

        public Mult(Expr left, Expr right) {
            this.left = left;
            this.right = right;
        }

        @Override
        int evaluate() {
            return left.evaluate() * right.evaluate();
        }

        @Override
        public String toString() {
            return "(" + left + " * " + right + ")";
        }
    }


    public static class CustomNumberGen extends SeriesGen<Integer> {
        @Override
        public Stream<Integer> generate(int depth) {
            return IntStream.range(0, 1 + depth).map(i -> 2 * i).boxed();
        }
    }

    public static class CustomCharGen extends SeriesGen<Character> {
        @Override
        public Stream<Character> generate(int depth) {
            return IntStream.range(0, 1+depth).mapToObj((int i) -> {
                if (i % 2 == 0) {
                    return (char) ('a' + i / 2);
                } else {
                    return (char) ('A' + i / 2);
                }
            });
        }
    }

    @Property(maxDepth = 4)
    @RegisterGenerator(CustomNumberGen.class)
    public void genList(List<Integer> list) {
        System.out.println(list);
    }

    @Property(maxDepth = 4)
    public void genList2(List<@From(CustomNumberGen.class) Integer> list) {
        System.out.println(list);
    }

    @Property(maxDepth = 4)
    @RegisterGenerator(CustomNumberGen.class)
    @RegisterGenerator(CustomCharGen.class)
    public void genMap(Map<Integer, Character> m) {
        System.out.println(m);
    }
}
